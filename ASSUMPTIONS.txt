Assumptions & Design Choices

1. Movement Logic
I decided to allow "floating" circles (circles don't fall when placed in empty space). If I enforced gravity, moving a circle from the bottom of a stack to the top of another would turn into a complex sliding puzzle. Floating mechanics simulate a robot arm holding the object or placing it on a temporary shelf, which makes the game much more playable.

2. Stacking Rules
I enforced the stacking rules (Red on top only, etc.) strictly in the vertical direction. Effectively, you can't sneak a move "under" a floating circle if it violates the rule. If there's a circle directly above or below, the rules apply.

3. Persistence
I kept the state in-memory for simplicity. A database felt like overkill for this specific project, so the board resets if the server restarts.

4. Grid Size
I used a 5x7 grid as it provides enough space to maneuver without making the board too large to view at a glance.

---

Design Decisions

Architecture
I separated the frontend and backend to keep the concerns clear. The backend acts as the source of truth and the "referee" for the game rules. This prevents any potential client-side state manipulation or "cheating" via the browser console.

Tech Stack
- Frontend: React + Vite. It's a fast, modern setup that I'm comfortable with.
- Backend: Express using TypeScript. It's lightweight and perfect for a simple JSON API.
- TypeScript: Used across the stack to share the GameState interfaces and catch existing bugs at compile time.

Validation
All move validation happens on the server. The frontend validates basics (like bounds) for UI feedback, but the server has the final say. This ensures the game state remains valid even if the client sends weird requests.
